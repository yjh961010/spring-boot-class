JPA
create: 새로운 테이블 만듦
ex) board, board1, board2 …
createdrop: board를 지우고 새로 만든다.
none: 수동으로 테이블 만들어야 함
update: 현재 테이블 있으면 만들지 말고 데이터 누적. 테이블이 없으면 새로 만든다. (많이 사용함) 시작시, 도메인과 스키마 비교하여 필요한 컬럼 추가 등의 작업 실행. 데이터는 삭제하지 않음.
validate: 기존과 새로운 것의 달라진 내용만 표시해줌. 스키마가 적합한지 검사함. 문제가 있으면 예외 발생.

properties에 jap추가
구조:
java ->
controller dto entity repostiry

@Entity -> 클래스이름이 테이블이름으로 들어감
@Table( name = "board")
@ID -> PK
@Column -> column명
@SequenceGaenrator -> name, sequenceName, initialValue , allocationSize - 시퀀스는 db가서 만들기
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "article_seq_generator")

*Repository 생성시
->interface ( extends CrudRepostiry < 테이블명 , pk타입>

 Controller에서의 처리
CRUD
 	<select *>
//1. 모든 데이터 가져오기
findAll은 iterator타입-> list타입으로받을거며 repository에서 override해서 정의해줘야함
//2. Model에 가져온 데이터넣기
//3. view페이지로 이동하기

	<insert>
//1.DTO를 Entitiy로 변환하기(articleForm에서 toEntity(테이블values) 만들어야함
//public Article toEntity() {
//return new Article(id , title , content);
ArticleForm으로 view에서 받아온값-> Article article = articleForm.toEntity();
//2.reopository로 엔티티를 db에 저장하기	
Article saved = articleRepository.save(article);

	<select ~ where>
id값을 인자로넘김. 받아올때는 @PathVariable 로 받아옴
ex) Article article = xxRepostiory.findById.orElse(null) // 찾았을때 값이있으면받아오고 없으면 null

	<update>
//수정하기전에 id가 먼저 존재하는지 확인하기
Article exist = articleRepository.findById(article.getId()).orElse(null);
if(exist != null) { //기존데이터가 존재하면 갱신하기
articleRepository.save(article);
}

	<delete>
//1.삭제할 대상을 가져오기
Article article = articleRepository.findById(id).orElse(null);
//2.대상 엔티티삭제하기
if(article !=null) {
articleRepository.delete(article);
}
//3.페이지이동 (viewresolver 영향안받기위해 redirect사용해줌)
	return	"redirect:/articles";


**특수쿼리**
ArticleRepository->

@Transactional //데이터에 직접 영향이가면
@Modifying(clearAutomatically = true)
@Query(value = sql쿼리문 where id = :a , nativeQuery=true)
int ex(@Param("a")int a)


-> controller 에서는  ex) int res = articleRepository.updateTest(1l);